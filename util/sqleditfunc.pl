#!/usr/bin/perl

use strict;
use warnings;
use List::Util 'any';

use Cwd 'abs_path';
our $ROOT;
BEGIN { ($ROOT = abs_path $0) =~ s{/util/sqleditfunc\.pl$}{}; }

use lib "$ROOT/lib";
use VNDB::Schema;

my $schema = VNDB::Schema::schema;
my $template = join '', <DATA>;

sub gensql {
  my $item = shift;

  # table_name_without_hist => [ column_names_without_chid ]
  my %ts = map
    +($_, [ map "\"$_->{name}\"", grep $_->{name} !~ /^chid$/, @{$schema->{"${_}_hist"}{cols}} ]),
    map /^${item}_/ && /^(.+)_hist$/ ? $1 : (), keys %$schema;

  my %replace = ( item => $item, itemtype => $schema->{$item}{dbentry_type} );

  $replace{createtemptables} = join "\n", map sprintf(
    "    CREATE TEMPORARY TABLE edit_%s (LIKE %s INCLUDING DEFAULTS INCLUDING CONSTRAINTS);\n".
    "    ALTER TABLE edit_%1\$s DROP COLUMN %s;",
    $_, $_ eq 'staff_alias' ? ($_, 'id') : ("${_}_hist", 'chid') # staff_alias copies from the non-_hist table, because it needs the sequence
  ), sort keys %ts;

  $replace{temptablenames} = join ', ', map "edit_$_", sort keys %ts;

  $replace{loadtemptables} = join "\n", map sprintf(
    "    INSERT INTO edit_%s (%s) SELECT %2\$s FROM %1\$s_hist WHERE chid = xchid;",
    $_, join ', ', @{$ts{$_}}), sort keys %ts;

  $replace{copyfromtemp} = join "\n", map sprintf(
    "  DELETE FROM %1\$s WHERE id = r.itemid;\n".
    "  INSERT INTO %1\$s (id, %2\$s) SELECT r.itemid, %2\$s FROM edit_%1\$s;\n".
    "  INSERT INTO %1\$s_hist (chid, %2\$s) SELECT r.chid, %2\$s FROM edit_%1\$s;",
    $_, join ', ', @{$ts{$_}}), grep $_ ne $item, sort keys %ts;

  $replace{copymainfromtemp} = sprintf
    "  INSERT INTO %1\$s_hist (chid, %2\$s) SELECT r.chid, %2\$s FROM edit_%1\$s;\n".
    "  UPDATE %1\$s SET locked = (SELECT ilock FROM edit_revision), hidden = (SELECT ihid FROM edit_revision),\n".
    "    %3\$s FROM edit_%1\$s x WHERE id = r.itemid;",
    $item, join(', ', @{$ts{$item}}), join(', ', map "$_ = x.$_", @{$ts{$item}});

  $template =~ s/{([a-z]+)}/$replace{$1}/gr;
}


open my $F, '>', "$ROOT/sql/editfunc.sql" or die $!;
print $F "-- Automatically generated by util/sqleditfunc.pl. DO NOT EDIT.\n";
print $F gensql $_ for sort grep $schema->{$_}{dbentry_type}, keys %$schema;


__DATA__

CREATE OR REPLACE FUNCTION edit_{itemtype}_init(xid integer, xrev integer) RETURNS void AS $$
DECLARE
  xchid integer;
BEGIN
  -- create tables, based on existing tables
  BEGIN
{createtemptables}
  EXCEPTION WHEN duplicate_table THEN
    TRUNCATE {temptablenames};
  END;
  -- Create edit_revision table and get relevant change ID.
  SELECT edit_revtable('{itemtype}', xid, xrev) INTO xchid;
  -- new entry, load defaults
  IF xchid IS NULL THEN
    INSERT INTO edit_{item} DEFAULT VALUES;
  -- otherwise, load revision
  ELSE
{loadtemptables}
  END IF;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION edit_{itemtype}_commit() RETURNS edit_rettype AS $$
DECLARE
  r edit_rettype;
BEGIN
  IF (SELECT COUNT(*) FROM edit_{item}) <> 1 THEN
    RAISE 'edit_{item} must have exactly one row!';
  END IF;
  SELECT INTO r * FROM edit_commit();
{copyfromtemp}
{copymainfromtemp}
  PERFORM edit_committed('{itemtype}', r);
  RETURN r;
END;
$$ LANGUAGE plpgsql;

