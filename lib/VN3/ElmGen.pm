# This module is responsible for generating elm3/Lib/Gen.elm. Variables and
# type definitions can be added from any Perl module by calling def() and
# elm_form() at file load time.

package VN3::ElmGen;

use strict;
use warnings;
use TUWF;
use Exporter 'import';
use VN3::Auth;
use VN3::Types;

our @EXPORT = qw/ elm_form /;


my $data = <<_;
-- This file is automatically generated from lib/VN3/ElmGen.pm
-- DO NOT EDIT!
module Lib.Gen exposing (..)

import Json.Encode as JE

type alias Medium =
  { qty    : Bool
  , single : String
  , plural : String
  }
_



# Formatting functions
sub indent($) { $_[0] =~ s/\n/\n  /gr }
sub list      { indent "\n[ ".join("\n, ", @_)."\n]" }
sub string($) { '"'.($_[0] =~ s/([\\"])/\\$1/gr).'"' }
sub tuple     { '('.join(', ', @_).')' }
sub bool($)   { $_[0] ? 'True' : 'False' }
sub to_camel  { (ucfirst $_[0]) =~ s/_([a-z])/'_'.uc $1/egr; }

# Output a variable definition: name, type, value
sub def($$$)  { $data .= sprintf "\n%s : %s\n%1\$s = %s\n", @_; }


# Define an Elm type corresponding to a TUWF::Validate schema
sub def_type {
    my($name, $obj) = @_;
    my @keys = $obj->{keys} ? grep $obj->{keys}{$_}{keys}||($obj->{keys}{$_}{values}&&$obj->{keys}{$_}{values}{keys}), sort keys %{$obj->{keys}} : ();

    def_type($name . to_camel($_), $obj->{keys}{$_}{values} || $obj->{keys}{$_}) for @keys;

    $data .= sprintf "\ntype alias %s = %s\n\n", $name, $obj->elm_type(
        keys => +{ map +($_, ($obj->{keys}{$_}{values} ? 'List ' : '') . $name . to_camel($_)), @keys }
    );
}


# Define an Elm JSON encoder taking a corresponding def_type() as input
sub encoder {
    my($name, $type, $obj) = @_;
    def $name, "$type -> JE.Value", $obj->elm_encoder(json_encode => 'JE.');
}


# Create type definitions and a JSON encoder for a typical form.
# Usage:
#
#   elm_form 'FormName', $TO_ELM_SCHEMA, $TO_SERVER_SCHEMA;
#
# That will define:
#
#   type alias FormName = { .. }
#   type alias FormNameSend = { .. }
#   formnameSendEncode : FormNameSend -> JE.Value
#
sub elm_form {
    my($name, $out, $in) = @_;
    def_type $name, $out->analyze;
    def_type $name.'Send', $in->analyze;
    encoder lc($name).'SendEncode', $name.'Send', $in->analyze;
}

sub print { print $data };


my $perms = VN3::Auth::listPerms();

def urlStatic         => String                  => string tuwf->conf->{url_static};
def userPerms         => 'List (Int, String)'    => list map tuple($perms->{$_}, string $_), sort keys %$perms;
def vnLengths         => 'List (Int, String)'    => list map tuple($_, string vn_length_display $_), 0..$#VN_LENGTHS;
def vnRelations       => 'List (String, String)' => list map tuple(string $_, string vn_relation_display $_), vn_relations;
def producerRelations => 'List (String, String)' => list map tuple(string $_, string producer_relation_display $_), keys %PRODUCER_RELATIONS;
def staffRoles        => 'List (String, String)' => list map tuple(string $_, string $STAFF_ROLES{$_}), keys %STAFF_ROLES;
def languages         => 'List (String, String)' => list map tuple(string $_, string $LANG{$_}), sort { $LANG{$a} cmp $LANG{$b} } keys %LANG;
def platforms         => 'List (String, String)' => list map tuple(string $_, string $PLATFORMS{$_}), keys %PLATFORMS;
def releaseTypes      => 'List String'           => list map string($_), release_types;
def producerTypes     => 'List (String, String)' => list map tuple(string $_, string $PRODUCER_TYPES{$_}), keys %PRODUCER_TYPES;
def minAges           => 'List (Int, String)'    => list map tuple($_, string minage_display_full $_), @MINAGE;
def resolutions       => 'List (String, String)' => list map tuple(string $_, string resolution_display_full $_), keys %RESOLUTIONS;
def voiced            => 'List String'           => list map string($_), @VOICED;
def animated          => 'List String'           => list map string($_), @ANIMATED;
def genders           => 'List (String, String)' => list map tuple(string $_, string gender_display $_), keys %GENDERS;
def bloodTypes        => 'List (String, String)' => list map tuple(string $_, string blood_type_display $_), keys %BLOOD_TYPES;
def charRoles         => 'List (String, String)' => list map tuple(string $_, string char_role_display $_), keys %CHAR_ROLES;
def vnlistStatus      => 'List (Int, String)'    => list map tuple($_, string $VNLIST_STATUS[$_]), 0..$#VNLIST_STATUS;

def emailPattern      => String                  => string { tuwf->compile({ email  => 1 })->analyze->html5_validation() }->{pattern};
def weburlPattern     => String                  => string { tuwf->compile({ weburl => 1 })->analyze->html5_validation() }->{pattern};
def vnvotePattern     => String                  => string { tuwf->compile({ vnvote => 1 })->analyze->html5_validation() }->{pattern};

def media => 'List (String, Medium)' =>
    list map tuple(
        string($_),
        sprintf('{ qty = %s, single = %s, plural = %s }', bool($MEDIA{$_}{qty}), string($MEDIA{$_}{single}), string($MEDIA{$_}{plural}))
    ), keys %MEDIA;


1;
